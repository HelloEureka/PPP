%% Purpose: srif filter to compute GPS data by utilizing PPP
%% Author: juntao on 2020/9/20
clear all;
global nmtx;
global nmtxY;
global std0;
global qstd0;
global map0;
nmtx = 5 + 32;
nmtxY = 5 + 32 + 32 * 2;

std0 = [9000, 0.2, 250, 250, 250];
qstd0 = [9000, 0.02 * sqrt(30/3600.0), 250, 250, 250];
map0 = [1, 1, 1, 1, 1];
infs = srif_initial();  % 初始化 信息滤波
nepoch = 0;

pfile = '.\\design_matrix.log';
fid = fopen(pfile);

if (fid == -1)
    disp(['can not open', pfile]);
    return
end

line = fgets(fid);
stan = line(1:4);
xyzinfo = sscanf(line(5:end), '%f');
rotmat = rot_enu2xyz(xyzinfo(4), xyzinfo(5));
est_epoch = [];

while (true)
    [infs, A, P, lcont] = srif_getMatrix(infs, fid);
    if (~lcont); break; end
    disp(['processing epoch ', num2str(nepoch)]);
    [infs, est] = srif_filter(infs, A, P);
    %disp(est);
    infs = srif_update(infs);
    nepoch = nepoch + 1;
    dxyz(1, :) = est(3:5); %% change the xyz into enu
    est(3:5) = dxyz * rotmat;
    est_epoch(nepoch, :) = est;
end

disp('processing done');

%% plot part
lw = 2.5;
intv = 30.0;
ulimit = 0.5;
h = figure(1);
textfont = 'normal';
lgsize = 20;
psize = 20;
fsize = 20;
HOURS_2 = ['  '; '02'; '04'; '06'; '08'; '10'; '12'; '14'; '16'; '18'; '20'; '22'; '24'];
set(0, 'defaultfigurecolor', 'w');
ax = axes('Parent', h, ...
    'XTick', [0:7200 / intv:nepoch], ...
    'XTickLabel', HOURS_2, ...
    'xlim', [0, nepoch], ...
    'LineWidth', lw, ...
    'ylim', [-ulimit, ulimit], ...
    'YTick', [-ulimit:ulimit / 5:ulimit], ...
    'FontWeight', textfont, ...
    'FontSize', psize, ...
    'FontName', 'Times New Roman');
hold(ax, 'all');
ylabel('ENU/m', 'FontName', 'Times New Roman', 'FontWeight', textfont, 'FontSize', fsize);
xlabel('HOUR/h', 'FontName', 'Times New Roman', 'FontWeight', textfont', 'FontSize', fsize);
plot(est_epoch(:, 3:5));
leg = legend(['E'; 'N'; 'U']);
set(leg, 'Orientation', 'horizon', 'Box', 'off', 'FontWeight', textfont, 'FontSize', lgsize, 'FontName', 'Times New Roman');
title(['PPP series of ', stan]);

%%
function [rotmat] = rot_enu2xyz(lat, lon)
    rotmat = zeros(3, 3);
    PI = 3.141592653;
    coslat = cos(lat - PI / 2);
    sinlat = sin(lat - PI / 2);
    coslon = cos(-PI / 2 - lon);
    sinlon = sin(-PI / 2 - lon);

    rotmat(1, 1) = coslon;
    rotmat(1, 2) = sinlon * coslat;
    rotmat(1, 3) = sinlon * sinlat;
    rotmat(2, 1) = -sinlon;
    rotmat(2, 2) = coslon * coslat;
    rotmat(2, 3) = coslon * sinlat;
    rotmat(3, 1) = 0;
    rotmat(3, 2) = -sinlat;
    rotmat(3, 3) = coslat;
end

function infs = srif_initial()
    global nmtx;
    global nmtxY;
    global std0;
    %% initialize the filter,introducing RECCLK/ZTD/X/Y/Z AMB..... PARAMETERS here
    infs = zeros(nmtxY, nmtx + 1);
    infs(1, 1) = 1 / std0(1); % RECCLK
    infs(2, 2) = 1 / std0(2); % ZTD

    for i = 3:5
        %% X/Y/Z
        infs(i, i) = 1 / std0(i);
    end

    %% AMBIGUITIES
    for i = 6:nmtx
        infs(i, i) = 0.01;
    end

end

function [infs, A, P, lcont] = srif_getMatrix(infs, fid)
    global nmtx
    %% get the corresponding matrix from debug file generated by BAMBOO PROGRAM created by juntao at wuhan university
    reset_list = [];
    data = [];
    nobs = 0;
    lcont = 1;
    A = [];
    P = [];
    if (feof(fid)); lcont = 0; return; end

    while (~feof(fid))
        line = fgets(fid);

        if size(line, 2) >= 14 && strncmp(line(1:14), 'AMBIGUITY_SLIP', 14)
            line = fgets(fid);
            reset_list = sscanf(line, '%d');
            continue;
        end

        if size(line, 2) >= 13 && strncmp(line(1:13), 'DESIGN_MATRIX', 13)
            nobs = sscanf(line(15:end), '%d');

            for i = 1:nobs
                line = fgets(fid);
                data(i, :) = sscanf(line, '%lf');
            end

            break
        end

    end

    %% using data to fill A/P
    for i = 1:size(data, 1)
        data(i, 7) = 1.0 / data(i, 7);
    end

    P = diag(data(:, 7));
    A = zeros(nobs, nmtx + 1);
    A(:, 1:5) = data(:, 1:5);
    A(:, nmtx + 1) = data(:, 6);
    %%% update coefficient of the ambiguity
    for i = 1:nobs
        isat = data(i, 8);

        if mod(i, 2) == 1
            A(i, 5 + isat) = 1;
        end

    end

    %% reset the corresponding ambiguity read from `reset_list` using gauss method
    for i = 1:size(reset_list, 1)
        ix = reset_list(i) + 5; %% the column which will be removed
        pivot = infs(ix, ix); %

        for irow = 1:nmtx%% iterate every row
            if ix == irow; continue; end

            if (infs(irow, ix) ~= 0)

                for icol = 1:nmtx + 1
                    if icol == ix; continue; end
                    infs(irow, icol) = infs(irow, icol) / infs(irow, ix) * pivot - infs(ix, icol);
                end

            end

        end

        infs(:, ix) = 0;
        infs(ix, :) = 0;
        infs(ix, ix) = 0.01;
    end

end

function [infs, est] = srif_filter(infs, A, P)
    global nmtx
    %% add the design matrix into information matrix
    nobs = size(A, 1);
    R = chol(P);
    B = R * A;
    infs(nmtx + 1:nmtx + nobs, 1:nmtx + 1) = B;
    %% by using QR transformation, making the infs into an upper triangle matrix
    [Q, R] = qr(infs(1:nmtx + nobs, 1:nmtx));
    infs(1:nmtx + nobs, nmtx + 1) = Q \ infs(1:nmtx + nobs, nmtx + 1);
    %% and solve the upper triangle matrix
    est = R(1:nmtx, 1:nmtx) \ infs(1:nmtx, nmtx + 1);
    %% update R matrix into infs
    infs(1:nmtx, 1:nmtx) = R(1:nmtx, 1:nmtx);
    infs(nmtx + 1:nmtx + nobs, 1:nmtx + 1) = 0.0;
end

function [infs] = srif_update(infs)
    global nmtx
    global qstd0;
    global map0;
    %% update the parameters here which are not constant by introducing transition matrix
    infs_u = zeros(10, 5 + nmtx + 1);
    infs_u(1:5, 1:5) = infs(1:5, 1:5);
    infs_u(1:5, 11:nmtx + 1 + 5) = infs(1:5, 6:nmtx + 1);
    map0 = [1, 1, 1, 1, 1];

    for i = 1:5
        infs_u(5 + i, i) = -1.0 / qstd0(i) * map0(i);
        infs_u(5 + i, 5 + i) = 1.0 / qstd0(i);
    end

    [Q, R] = qr(infs_u);
    infs(1:5, 1:nmtx + 1) = R(6:10, 6:nmtx + 1 + 5);
end
